awk '
BEGIN {
    OFS=";";
    print "I", "N", "P", "S", "U", "H";
    input_file = "/proc/bus/input/devices"; 
    current_record_number = 0;
    while ((getline line < input_file) > 0) 
        {
        current_record_number++; 
        $0 = line;
        split($0, fields, FS); 
        $1 = fields[1]; 
        if (substr($0, 1, 2) == "I:") 
            { 
            if (current_record_number > 1) 
                { 
                print_data(values);
                }
            reset_data(values);
            }
        key = substr($1, 1, 1);
        match($0, / (.*)/);
        value = substr($0, RSTART + 1);
        if (key == "B") 
            {
            if (values["B"] != "") 
                {
                values["B"] = values["B"] " | " value;
                } 
            else 
                {
                values["B"] = value;
                }
            } 
            else 
                {
                values[key] = value;
                }
    }

    close(input_file); 
    print_data(values);
    exit;
}
function reset_data(data) {
    data["I"] = ""; data["N"] = ""; data["P"] = "";
    data["S"] = ""; data["U"] = ""; data["H"] = "";
    data["B"] = "";
}
function print_data(data) {
    gsub(/^[ \t]+|[ \t]+$/, "", data["B"]);
    print data["I"], data["N"], data["P"], data["S"], data["U"], data["H"], data["B"];
}
'


awk '
BEGIN {
    # Set the Output Field Separator to a semicolon.
    OFS=";";
    
    # Print the header row.
    print "I", "N", "P", "S", "U", "H", "B";

    # --- Specify the devices file directly here ---
    # You MUST specify the file name here if you're not passing it as an argument.
    # Replace "your_devices_file.txt" with the actual path to your file.
    input_file = "your_devices_file.txt"; 

    # Initialize a counter for NR (Record Number), as getline won't update it automatically
    # This will simulate NR for your logic that checks NR > 1
    current_record_number = 0;

    # Explicit loop to read the file line by line
    # (getline line < input_file) reads a line into the variable 'line'
    # > 0 means the read was successful (not end-of-file or error)
    while ((getline line < input_file) > 0) {
        current_record_number++; # Manually increment our simulated NR

        # --- Begin adapted logic from your original script's main blocks ---

        # Simulate setting $0 and $1 for your existing logic
        # This is crucial because your original script relies on $0 and $1
        # from awk's default parsing.
        $0 = line;
        split($0, fields, FS); # Split the line into fields using default FS (space/tab)
        $1 = fields[1];        # Set $1 from the split

        # The /^I:/ rule matches the first line of a new device block.
        # Check if the current line starts with "I:"
        if (substr($0, 1, 2) == "I:") { # Using substr instead of /^I:/ regex
            # If this is not the first device we have seen (simulated NR > 1),
            # print the data we collected for the *previous* device.
            if (current_record_number > 1) { # Use our simulated counter
                print_data(values);
            }
            # Reset the array for the new device.
            reset_data(values);
        }

        # For every line in the input... (this is the logic for each line)
        # Get the key (the first character, e.g., "I", "N", "B").
        key = substr($1, 1, 1);
        
        # Get the value by removing the key part (e.g., "I: ", "N: ").
        # It finds the first space and takes the rest of the line.
        match($0, / (.*)/);
        value = substr($0, RSTART + 1);
        
        # For the "B" key, append the new value. For all other keys, just assign it.
        if (key == "B") {
            # If the "B" field already has content, add a separator before the new value.
            if (values["B"] != "") {
                values["B"] = values["B"] " | " value;
            } else {
                values["B"] = value;
            }
        } else {
            values[key] = value;
        }
        # --- End adapted logic ---
    }

    close(input_file); # Important: Close the file after you're done reading it

    # The END block equivalent runs after the very last line of input has been processed.
    # This is needed to print the data for the final device in the file.
    print_data(values);

    # Optionally, exit to prevent awk from trying to process any further (non-existent) input
    exit;
}

# --- Functions (These remain largely the same, but are called from BEGIN) ---

# This function runs before processing a new device block.
# It resets the data array to ensure no data from a previous
# device leaks into the current one.
function reset_data(data) {
    data["I"] = ""; data["N"] = ""; data["P"] = "";
    data["S"] = ""; data["U"] = ""; data["H"] = "";
    data["B"] = "";
}

# This function runs after processing each device block.
# It prints the collected data in the correct column order.
function print_data(data) {
    # The gsub is used to remove leading/trailing whitespace from the combined "B" field.
    gsub(/^[ \t]+|[ \t]+$/, "", data["B"]);
    print data["I"], data["N"], data["P"], data["S"], data["U"], data["H"], data["B"];
}

# No other rules are needed outside the BEGIN block, as all processing is now explicit within it.
'
